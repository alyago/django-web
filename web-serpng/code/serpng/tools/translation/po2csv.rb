#!/usr/bin/ruby

# This script processes a .po file generated by Django's makemessages utility and
# outputs a .csv file suitable for importing into an Excel spreadsheet.
#
# Arguments (command-line):
#   A string that denotes the locale name for the .po file (e.g., fr_FR).  The script
#   will take as input file the django.po file that resides within the locale
#   subdirectory that is associated with the locale name.
# 
# Outputs:
#   A .csv file named django.csv that is written to the same directory as the
#   .po file.  Note that the .csv file is actually separated with the "#" delimiter,
#   and not the "," delimiter.
#
# Example:
#
# Two translation blocks in .po ...
#
# #. Translators: This is a link to a page with information about jobs in various cities.
# #: jobs/translation_strings.py:16
# #: jobs/templates/bottom/jobs_bottom_footer.html:6
# msgid "Local Jobs"
# msgstr ""
#
# #. Translators: This is a link to a page with information about salaries for various jobs.
# #: jobs/translation_strings.py:19
# #: jobs/templates/bottom/jobs_bottom_footer.html:7
# msgid "Job Salaries"
# msgstr ""
#
# Will result in the following two lines in .csv ...
#
# (1) This is a link to a page with information about jobs in various cities.#Local Jobs##jobs/translation_strings.py:16 jobs/templates/bottom/jobs_bottom_footer.html:6
# (1) This is a link to a page with information about salaries for various jobs.#Job Salaries##jobs/translation_strings.py:19 jobs/templates/bottom/jobs_bottom_footer.html:7

#
# Grab locale name from command line.
#
if ARGV[0].nil?
  puts "Please provide a locale name."
  puts "Usage: po2csv.rb <locale name>"
  puts "Example: po2csv.rb fr_CA"
  exit
else
  locale_name = ARGV[0]
end

#
# Construct both input and output file names; open output file for writing.
#
git_dir = %x(git rev-parse --show-toplevel).chomp
po_file_name = "#{git_dir}/code/serpng/locale/#{locale_name}/LC_MESSAGES/django.po"
csv_file_name = "#{git_dir}/code/serpng/locale/#{locale_name}/LC_MESSAGES/django.csv"
f_csv = File.new(csv_file_name, "w")

#
# Delimiters.
#

# '#' separates columns in an Excel spreadsheet.
$main_delimiter = '#'

# ' ' separates, within a single Excel column, original file locations.
# (used for reconstructing a .po file from a .csv file)
$file_locations_delimiter = ' '

# ';' separates, within a single Excel column, original multiline strings.
# (used for reconstructing a .po file from a .csv file)
$multiline_msgid_str_delimiter = ';'

#
# Helper functions.
#

# In .po files, strings to be translated are wrapped in double quotes.
# This function strips the double quotes from the string.
def strip_double_quotes(orig_str)
  orig_str[1...-1]
end

#
# Main
#
File.open(po_file_name) do |f|
  should_translate = false
  comment = ""
  comment_count = 1
  file_locations = ""
  msgid_str_array = []
  has_multiline_msgid_str = false

  # Write a line of column names separated by the main delimiter.
  f_csv.puts "Comments for Translators#{$main_delimiter}English#{$main_delimiter}Translation#{$main_delimiter}Original File Locations#{$main_delimiter}Original Multiline String"

  f.each do |po_line|
    # Each translation block in the .po file is separated by a newline.
    # When we encounter a newline (an empty line), reset the should_translate
    # flag to false.
    if po_line.chomp.strip == ""
      should_translate = false
    end

    # Most non-empty lines in the .po file start with a string that indicates
    # what the line contains.
    startswith, line_body = po_line.chomp.split(' ', 2)

    # Perform different actions based on the line indicator string.
    case startswith
    when '#.'
      # If a line starts with '#.', this means that the line is a translator comment.
      # If there is a '#.', it always comes at the beginning of a translation block.
      # If a block starts with a '#.', translate the block.  If there are no
      # translator comments for a block, do not translate the block.
      should_translate = true

      # Accumulate all translator comments for the current translation block.
      comment_head, comment_body = line_body.strip.split(':', 2)
      if (comment_head == "Translators")
        # Remove the "Translators:" part of the comment. Instead, number
        # the comment (there may be multiple translator comments coming from
        # multiple contexts for the same string to be translated) 
        comment = comment + "(#{comment_count})" + comment_body + " "
        comment_count = comment_count + 1
      else
        # No need to remove "Translators"; simply accumulate.
        comment = comment + comment_head + " "
      end
    when '#:'
      # If a line starts with '#:', this means that the line contains the file
      # location from which the string to be translated was extracted.
      # '#:' lines come immediately after '#.' lines, so we can now write the
      # accumulated translator comments to the .csv file.
      if should_translate
        # Flush accumulated comments.
        if (comment != "")
          f_csv.print comment.strip + $main_delimiter
          comment = ""
          comment_count = 1
        end

        # Accumulate file location information and write it out at the end of
        # a .csv file line.
        # (used for later reconstruction of .po file from .csv file)
        if (file_locations == "")
          file_locations = line_body
        else
          file_locations = file_locations + $file_locations_delimiter + line_body
        end
      end
    when 'msgid'
      # If a line starts with 'msgid', this means that the line contains the 
      # string that is to be translated.  Write this string out to the .csv file.
      # There is a special case for long strings, which span over multiple lines
      # in the .po file.  In that case, accumulate the long strings and write them
      # to the .csv file later as one long string.
      if should_translate
        msgid_str = strip_double_quotes(line_body)
        if msgid_str == ""
          has_multiline_msgid_str = true
        else
          # Two delimiters are printed consecutively because the consecutive delimiters
          # constitute an empty column - the column for the translated strings to be filled
          # in.
          f_csv.print msgid_str + $main_delimiter + $main_delimiter

          # Flush accumulated file_locations.
          f_csv.puts file_locations
          file_locations = ""
        end
      end
    when 'msgstr'
      # If a line starts with 'msgstr', this means that the line contains the 
      # string that has been translated. In an original .po file, this string 
      # is empty.  Since 'msgstr' lines follow 'msgid' lines immediately,
      # a 'msgstr' line indicates that all multi-line strings from the msgid
      # lines have been accumulated and can be written to the .csv file.

      # Flush any accumulated long strings.
      if has_multiline_msgid_str
        # Write out long string to .csv file.
        f_csv.print msgid_str_array.join + $main_delimiter + $main_delimiter

        # Flush accumulated file_locations.
        f_csv.print file_locations + $main_delimiter
        file_locations = ""

        # Flush the original long string, separated by its own delimiter.
        # (this is used to reconstruct the .po later) 
        f_csv.puts msgid_str_array.join($multiline_msgid_str_delimiter)

        # Reset multiline strings state variable.
        has_multiline_msgid_str = false
        msgid_str_array = []
      end
    else
      # If a line doesn't start with any of the special indicator strings above,
      # then we may need to accumulate the line as part of a multiline string.
      if has_multiline_msgid_str
        msgid_str_array.push(strip_double_quotes(po_line.chomp))
      end
    end
  end
end

#
# Close output file.
#
f_csv.close